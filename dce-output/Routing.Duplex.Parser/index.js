// Generated by purs version 0.13.8
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Array_NonEmpty = require("../Data.Array.NonEmpty/index.js");
var Data_Array_NonEmpty_Internal = require("../Data.Array.NonEmpty.Internal/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_String_CodeUnits = require("../Data.String.CodeUnits/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Global_Unsafe = require("../Global.Unsafe/index.js");
var Expected = (function () {
    function Expected(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Expected.create = function (value0) {
        return function (value1) {
            return new Expected(value0, value1);
        };
    };
    return Expected;
})();
var ExpectedEndOfPath = (function () {
    function ExpectedEndOfPath(value0) {
        this.value0 = value0;
    };
    ExpectedEndOfPath.create = function (value0) {
        return new ExpectedEndOfPath(value0);
    };
    return ExpectedEndOfPath;
})();
var MissingParam = (function () {
    function MissingParam(value0) {
        this.value0 = value0;
    };
    MissingParam.create = function (value0) {
        return new MissingParam(value0);
    };
    return MissingParam;
})();
var EndOfPath = (function () {
    function EndOfPath() {

    };
    EndOfPath.value = new EndOfPath();
    return EndOfPath;
})();
var Fail = (function () {
    function Fail(value0) {
        this.value0 = value0;
    };
    Fail.create = function (value0) {
        return new Fail(value0);
    };
    return Fail;
})();
var Success = (function () {
    function Success(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Success.create = function (value0) {
        return function (value1) {
            return new Success(value0, value1);
        };
    };
    return Success;
})();
var Alt = (function () {
    function Alt(value0) {
        this.value0 = value0;
    };
    Alt.create = function (value0) {
        return new Alt(value0);
    };
    return Alt;
})();
var Chomp = (function () {
    function Chomp(value0) {
        this.value0 = value0;
    };
    Chomp.create = function (value0) {
        return new Chomp(value0);
    };
    return Chomp;
})();
var Prefix = (function () {
    function Prefix(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Prefix.create = function (value0) {
        return function (value1) {
            return new Prefix(value0, value1);
        };
    };
    return Prefix;
})();
var take = new Chomp(function (state) {
    var v = Data_Array.uncons(state.segments);
    if (v instanceof Data_Maybe.Just) {
        return new Success({
            segments: v.value0.tail,
            params: state.params,
            hash: state.hash
        }, v.value0.head);
    };
    return new Fail(EndOfPath.value);
});
var prefix = Prefix.create;
var parsePath = (function () {
    var toRouteState = function (v) {
        return {
            segments: v.value0.value0,
            params: v.value0.value1,
            hash: v.value1
        };
    };
    var splitNonEmpty = function (v) {
        return function (v1) {
            if (v1 === "") {
                return [  ];
            };
            return Data_String_Common.split(v)(v1);
        };
    };
    var splitSegments = (function () {
        var $2903 = splitNonEmpty("/");
        return function ($2904) {
            return (function (v) {
                if (v.length === 2 && (v[0] === "" && v[1] === "")) {
                    return [ "" ];
                };
                return Data_Functor.map(Data_Functor.functorArray)(Global_Unsafe.unsafeDecodeURIComponent)(v);
            })($2903($2904));
        };
    })();
    var splitAt = function (k) {
        return function (p) {
            return function (str) {
                var v = Data_String_CodeUnits.indexOf(p)(str);
                if (v instanceof Data_Maybe.Just) {
                    return new Data_Tuple.Tuple(Data_String_CodeUnits.take(v.value0)(str), Data_String_CodeUnits.drop(v.value0 + Data_String_CodeUnits.length(p) | 0)(str));
                };
                if (v instanceof Data_Maybe.Nothing) {
                    return k(str);
                };
                throw new Error("Failed pattern match at Routing.Duplex.Parser (line 183, column 5 - line 185, column 23): " + [ v.constructor.name ]);
            };
        };
    };
    var splitKeyValue = (function () {
        var $2905 = Data_Bifunctor.bimap(Data_Tuple.bifunctorTuple)(Global_Unsafe.unsafeDecodeURIComponent)(Global_Unsafe.unsafeDecodeURIComponent);
        var $2906 = splitAt(Data_Function.flip(Data_Tuple.Tuple.create)(""))("=");
        return function ($2907) {
            return $2905($2906($2907));
        };
    })();
    var splitParams = (function () {
        var $2908 = Data_Functor.map(Data_Functor.functorArray)(splitKeyValue);
        var $2909 = splitNonEmpty("&");
        return function ($2910) {
            return $2908($2909($2910));
        };
    })();
    var splitPath = (function () {
        var $2911 = Data_Bifunctor.bimap(Data_Tuple.bifunctorTuple)(splitSegments)(splitParams);
        var $2912 = splitAt(Data_Function.flip(Data_Tuple.Tuple.create)(""))("?");
        return function ($2913) {
            return $2911($2912($2913));
        };
    })();
    var $2914 = Data_Bifunctor.lmap(Data_Tuple.bifunctorTuple)(splitPath);
    var $2915 = splitAt(Data_Function.flip(Data_Tuple.Tuple.create)(""))("#");
    return function ($2916) {
        return toRouteState($2914($2915($2916)));
    };
})();
var param = function (key) {
    return new Chomp(function (state) {
        var v = Data_Tuple.lookup(Data_Foldable.foldableArray)(Data_Eq.eqString)(key)(state.params);
        if (v instanceof Data_Maybe.Just) {
            return new Success(state, v.value0);
        };
        return Fail.create(new MissingParam(key));
    });
};
var $$int = (function () {
    var $2917 = Data_Maybe.maybe(new Data_Either.Left("Int"))(Data_Either.Right.create);
    return function ($2918) {
        return $2917(Data_Int.fromString($2918));
    };
})();
var functorRouteResult = new Data_Functor.Functor(function (f) {
    return function (m) {
        if (m instanceof Fail) {
            return new Fail(m.value0);
        };
        if (m instanceof Success) {
            return new Success(m.value0, f(m.value1));
        };
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 53, column 1 - line 53, column 58): " + [ m.constructor.name ]);
    };
});
var functorRouteParser = new Data_Functor.Functor(function (f) {
    return function (m) {
        if (m instanceof Alt) {
            return new Alt(Data_Functor.map(Data_Array_NonEmpty_Internal.functorNonEmptyArray)(Data_Functor.map(functorRouteParser)(f))(m.value0));
        };
        if (m instanceof Chomp) {
            return new Chomp(Data_Functor.map(Data_Functor.functorFn)(Data_Functor.map(functorRouteResult)(f))(m.value0));
        };
        if (m instanceof Prefix) {
            return new Prefix(m.value0, Data_Functor.map(functorRouteParser)(f)(m.value1));
        };
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 72, column 1 - line 72, column 58): " + [ m.constructor.name ]);
    };
});
var end = new Chomp(function (state) {
    var v = Data_Array.head(state.segments);
    if (v instanceof Data_Maybe.Nothing) {
        return new Success(state, Data_Unit.unit);
    };
    if (v instanceof Data_Maybe.Just) {
        return new Fail(new ExpectedEndOfPath(v.value0));
    };
    throw new Error("Failed pattern match at Routing.Duplex.Parser (line 254, column 3 - line 256, column 45): " + [ v.constructor.name ]);
});
var chompPrefix = function (pre) {
    return function (state) {
        var v = Data_Array.head(state.segments);
        if (v instanceof Data_Maybe.Just && pre === v.value0) {
            return new Success({
                segments: Data_Array.drop(1)(state.segments),
                params: state.params,
                hash: state.hash
            }, Data_Unit.unit);
        };
        if (v instanceof Data_Maybe.Just) {
            return Fail.create(new Expected(pre, v.value0));
        };
        return Fail.create(EndOfPath.value);
    };
};
var runRouteParser = (function () {
    var goAlt = function (v) {
        return function (v1) {
            return function (v2) {
                if (v1 instanceof Fail) {
                    return runRouteParser(v)(v2);
                };
                return v1;
            };
        };
    };
    var go = function ($copy_state) {
        return function ($copy_v) {
            var $tco_var_state = $copy_state;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(state, v) {
                if (v instanceof Alt) {
                    $tco_done = true;
                    return Data_Foldable.foldl(Data_Array_NonEmpty_Internal.foldableNonEmptyArray)(goAlt(state))(new Fail(EndOfPath.value))(v.value0);
                };
                if (v instanceof Chomp) {
                    $tco_done = true;
                    return v.value0(state);
                };
                if (v instanceof Prefix) {
                    var v1 = chompPrefix(v.value0)(state);
                    if (v1 instanceof Fail) {
                        $tco_done = true;
                        return new Fail(v1.value0);
                    };
                    if (v1 instanceof Success) {
                        $tco_var_state = v1.value0;
                        $copy_v = v.value1;
                        return;
                    };
                    throw new Error("Failed pattern match at Routing.Duplex.Parser (line 149, column 7 - line 151, column 40): " + [ v1.constructor.name ]);
                };
                throw new Error("Failed pattern match at Routing.Duplex.Parser (line 145, column 14 - line 151, column 40): " + [ v.constructor.name ]);
            };
            while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_state, $copy_v);
            };
            return $tco_result;
        };
    };
    return go;
})();
var run = function (p) {
    var $2919 = Data_Function.flip(runRouteParser)(p);
    return function ($2920) {
        return (function (v) {
            if (v instanceof Fail) {
                return new Data_Either.Left(v.value0);
            };
            if (v instanceof Success) {
                return new Data_Either.Right(v.value1);
            };
            throw new Error("Failed pattern match at Routing.Duplex.Parser (line 188, column 49 - line 190, column 29): " + [ v.constructor.name ]);
        })($2919(parsePath($2920)));
    };
};
var as = function (print) {
    return function (decode) {
        return function (p) {
            return new Chomp(function (state) {
                var v = runRouteParser(state)(p);
                if (v instanceof Fail) {
                    return new Fail(v.value0);
                };
                if (v instanceof Success) {
                    var v1 = decode(v.value1);
                    if (v1 instanceof Data_Either.Left) {
                        return Fail.create(new Expected(v1.value0, print(v.value1)));
                    };
                    if (v1 instanceof Data_Either.Right) {
                        return new Success(v.value0, v1.value0);
                    };
                    throw new Error("Failed pattern match at Routing.Duplex.Parser (line 242, column 7 - line 244, column 36): " + [ v1.constructor.name ]);
                };
                throw new Error("Failed pattern match at Routing.Duplex.Parser (line 239, column 3 - line 244, column 36): " + [ v.constructor.name ]);
            });
        };
    };
};
var applyRouteParser = new Control_Apply.Apply(function ($dollar__unused) {
    return functorRouteParser;
}, function (fx) {
    return function (x) {
        return new Chomp(function (state) {
            var v = runRouteParser(state)(fx);
            if (v instanceof Fail) {
                return new Fail(v.value0);
            };
            if (v instanceof Success) {
                return Data_Functor.map(functorRouteResult)(v.value1)(runRouteParser(v.value0)(x));
            };
            throw new Error("Failed pattern match at Routing.Duplex.Parser (line 76, column 5 - line 78, column 56): " + [ v.constructor.name ]);
        });
    };
});
var applicativeRouteParser = new Control_Applicative.Applicative(function ($dollar__unused) {
    return applyRouteParser;
}, (function () {
    var $2921 = Data_Function.flip(Success.create);
    return function ($2922) {
        return Chomp.create($2921($2922));
    };
})());
var altSnoc = function (ls) {
    return function (v) {
        var v1 = function (v2) {
            return Data_Array_NonEmpty.snoc(ls)(v);
        };
        if (v instanceof Prefix) {
            var $2864 = Data_Array_NonEmpty.last(ls);
            if ($2864 instanceof Prefix) {
                var $2865 = v.value0 === $2864.value0;
                if ($2865) {
                    return Data_Array_NonEmpty["snoc'"](Data_Array_NonEmpty.init(ls))(new Prefix(v.value0, Control_Alt.alt(altRouteParser)($2864.value1)(v.value1)));
                };
                return v1(true);
            };
            return v1(true);
        };
        return v1(true);
    };
};
var altRouteParser = new Control_Alt.Alt(function ($dollar__unused) {
    return functorRouteParser;
}, function (v) {
    return function (v1) {
        if (v instanceof Alt && v1 instanceof Alt) {
            return new Alt(altAppend(v.value0)(v1.value0));
        };
        if (v instanceof Alt) {
            return new Alt(altSnoc(v.value0)(v1));
        };
        if (v1 instanceof Alt) {
            return new Alt(altCons(v)(v1.value0));
        };
        if (v instanceof Prefix && (v1 instanceof Prefix && v.value0 === v1.value0)) {
            return new Prefix(v.value0, Control_Alt.alt(altRouteParser)(v.value1)(v1.value1));
        };
        return new Alt(Data_Array_NonEmpty.cons(v)(Data_Array_NonEmpty.singleton(v1)));
    };
});
var altCons = function (v) {
    return function (rs) {
        var v1 = function (v2) {
            return Data_Array_NonEmpty.cons(v)(rs);
        };
        if (v instanceof Prefix) {
            var $2884 = Data_Array_NonEmpty.head(rs);
            if ($2884 instanceof Prefix) {
                var $2885 = v.value0 === $2884.value0;
                if ($2885) {
                    return Data_Array_NonEmpty["cons'"](new Prefix(v.value0, Control_Alt.alt(altRouteParser)(v.value1)($2884.value1)))(Data_Array_NonEmpty.tail(rs));
                };
                return v1(true);
            };
            return v1(true);
        };
        return v1(true);
    };
};
var altAppend = function ($copy_ls) {
    return function ($copy_rs) {
        var $tco_var_ls = $copy_ls;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(ls, rs) {
            var v = function (v1) {
                if (Data_Boolean.otherwise) {
                    return Data_Semigroup.append(Data_Array_NonEmpty_Internal.semigroupNonEmptyArray)(ls)(rs);
                };
                throw new Error("Failed pattern match at Routing.Duplex.Parser (line 98, column 1 - line 101, column 32): " + [ ls.constructor.name, rs.constructor.name ]);
            };
            var $2894 = Data_Array_NonEmpty.last(ls);
            if ($2894 instanceof Prefix) {
                var $2895 = Data_Array_NonEmpty.head(rs);
                if ($2895 instanceof Prefix) {
                    var $2896 = $2894.value0 === $2895.value0;
                    if ($2896) {
                        var rs$prime = Data_Array_NonEmpty["cons'"](new Prefix($2894.value0, Control_Alt.alt(altRouteParser)($2894.value1)($2895.value1)))(Data_Array_NonEmpty.tail(rs));
                        var v1 = Data_Array_NonEmpty.fromArray(Data_Array_NonEmpty.init(ls));
                        if (v1 instanceof Data_Maybe.Just) {
                            $tco_var_ls = v1.value0;
                            $copy_rs = rs$prime;
                            return;
                        };
                        if (v1 instanceof Data_Maybe.Nothing) {
                            $tco_done = true;
                            return rs$prime;
                        };
                        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 110, column 9 - line 112, column 26): " + [ v1.constructor.name ]);
                    };
                    $tco_done = true;
                    return v(true);
                };
                $tco_done = true;
                return v(true);
            };
            $tco_done = true;
            return v(true);
        };
        while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_ls, $copy_rs);
        };
        return $tco_result;
    };
};
var $$default = (function () {
    var $2923 = Data_Function.flip(Control_Alt.alt(altRouteParser));
    var $2924 = Control_Applicative.pure(applicativeRouteParser);
    return function ($2925) {
        return $2923($2924($2925));
    };
})();
var optional = (function () {
    var $2926 = $$default(Data_Maybe.Nothing.value);
    var $2927 = Data_Functor.map(functorRouteParser)(Data_Maybe.Just.create);
    return function ($2928) {
        return $2926($2927($2928));
    };
})();
module.exports = {
    Expected: Expected,
    ExpectedEndOfPath: ExpectedEndOfPath,
    MissingParam: MissingParam,
    EndOfPath: EndOfPath,
    Fail: Fail,
    Success: Success,
    Alt: Alt,
    Chomp: Chomp,
    Prefix: Prefix,
    runRouteParser: runRouteParser,
    parsePath: parsePath,
    run: run,
    prefix: prefix,
    take: take,
    param: param,
    "default": $$default,
    optional: optional,
    as: as,
    "int": $$int,
    end: end,
    functorRouteResult: functorRouteResult,
    functorRouteParser: functorRouteParser,
    applyRouteParser: applyRouteParser,
    applicativeRouteParser: applicativeRouteParser,
    altRouteParser: altRouteParser
};
