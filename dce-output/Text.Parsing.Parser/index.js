// Generated by purs version 0.13.6
import * as Control_Alt from "../Control.Alt/index.js";
import * as Control_Alternative from "../Control.Alternative/index.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Control_Lazy from "../Control.Lazy/index.js";
import * as Control_Monad_Error_Class from "../Control.Monad.Error.Class/index.js";
import * as Control_Monad_Except_Trans from "../Control.Monad.Except.Trans/index.js";
import * as Control_Monad_State_Class from "../Control.Monad.State.Class/index.js";
import * as Control_Monad_State_Trans from "../Control.Monad.State.Trans/index.js";
import * as Control_Plus from "../Control.Plus/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Identity from "../Data.Identity/index.js";
import * as Data_Newtype from "../Data.Newtype/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Text_Parsing_Parser_Pos from "../Text.Parsing.Parser.Pos/index.js";
var ParseState = (function () {
    function ParseState(value0, value1, value2) {
        this.value0 = value0;
        this.value1 = value1;
        this.value2 = value2;
    };
    ParseState.create = function (value0) {
        return function (value1) {
            return function (value2) {
                return new ParseState(value0, value1, value2);
            };
        };
    };
    return ParseState;
})();
var ParseError = (function () {
    function ParseError(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ParseError.create = function (value0) {
        return function (value1) {
            return new ParseError(value0, value1);
        };
    };
    return ParseError;
})();
var ParserT = function (x) {
    return x;
};
var parseErrorPosition = function (v) {
    return v.value1;
};
var parseErrorMessage = function (v) {
    return v.value0;
};
var newtypeParserT = new Data_Newtype.Newtype(function (n) {
    return n;
}, ParserT);
var runParserT = function (dictMonad) {
    return function (s) {
        return function (p) {
            var initialState = new ParseState(s, Text_Parsing_Parser_Pos.initialPos, false);
            return Control_Monad_State_Trans.evalStateT(((dictMonad.Bind1()).Apply0()).Functor0())(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap(newtypeParserT)(p)))(initialState);
        };
    };
};
var runParser = function (s) {
    var $2994 = Data_Newtype.unwrap(Data_Identity.newtypeIdentity);
    var $2995 = runParserT(Data_Identity.monadIdentity)(s);
    return function ($2996) {
        return $2994($2995($2996));
    };
};
var monadThrowParserT = function (dictMonad) {
    return Control_Monad_Except_Trans.monadThrowExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));
};
var monadStateParserT = function (dictMonad) {
    return Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(dictMonad));
};
var position = function (dictMonad) {
    return Control_Monad_State_Class.gets(monadStateParserT(dictMonad))(function (v) {
        return v.value1;
    });
};
var lazyParserT = new Control_Lazy.Lazy(function (f) {
    return Control_Lazy.defer(Control_Monad_State_Trans.lazyStateT)((function () {
        var $2997 = Data_Newtype.unwrap(newtypeParserT);
        return function ($2998) {
            return Control_Monad_Except_Trans.runExceptT($2997(f($2998)));
        };
    })());
});
var functorParserT = function (dictFunctor) {
    return Control_Monad_Except_Trans.functorExceptT(Control_Monad_State_Trans.functorStateT(dictFunctor));
};
var failWithPosition = function (dictMonad) {
    return function (message) {
        return function (pos) {
            return Control_Monad_Error_Class.throwError(monadThrowParserT(dictMonad))(new ParseError(message, pos));
        };
    };
};
var bindParserT = function (dictMonad) {
    return Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));
};
var fail = function (dictMonad) {
    return function (message) {
        return Control_Bind.bindFlipped(bindParserT(dictMonad))(failWithPosition(dictMonad)(message))(position(dictMonad));
    };
};
var applyParserT = function (dictMonad) {
    return Control_Monad_Except_Trans.applyExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));
};
var applicativeParserT = function (dictMonad) {
    return Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));
};
var altParserT = function (dictMonad) {
    return new Control_Alt.Alt(function ($dollar__unused) {
        return functorParserT(((dictMonad.Bind1()).Apply0()).Functor0());
    }, function (p1) {
        return function (p2) {
            return ParserT(Control_Monad_Except_Trans.ExceptT(Control_Monad_State_Trans.StateT(function (v) {
                return Control_Bind.bind(dictMonad.Bind1())(Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap(newtypeParserT)(p1)))(new ParseState(v.value0, v.value1, false)))(function (v1) {
                    if (v1.value0 instanceof Data_Either.Left && !v1.value1.value2) {
                        return Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap(newtypeParserT)(p2)))(v);
                    };
                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v1.value0, v1.value1));
                });
            })));
        };
    });
};
var plusParserT = function (dictMonad) {
    return new Control_Plus.Plus(function ($dollar__unused) {
        return altParserT(dictMonad);
    }, fail(dictMonad)("No alternative"));
};
var alternativeParserT = function (dictMonad) {
    return new Control_Alternative.Alternative(function ($dollar__unused) {
        return applicativeParserT(dictMonad);
    }, function ($dollar__unused) {
        return plusParserT(dictMonad);
    });
};
export {
    ParseError,
    parseErrorMessage,
    parseErrorPosition,
    ParseState,
    ParserT,
    runParser,
    runParserT,
    position,
    fail,
    failWithPosition,
    newtypeParserT,
    lazyParserT,
    functorParserT,
    applyParserT,
    applicativeParserT,
    bindParserT,
    monadStateParserT,
    monadThrowParserT,
    altParserT,
    plusParserT,
    alternativeParserT
};
